## The Theory of Constraints
```
In this section of the course, we're going to talk about the theory of constraints. The theory of constraints is a systematic way of analyzing flow problems and making improvements in a process flow. The theory of constraints was originally developed by Elihu Goldratt and was originally published in his book, The Goal. His book is a classic in this area. Here's an example. In a company I worked in, we had a task of taking over 100 legacy applications that needed to be upgraded to a new version of Microsoft Visual Studio .NET, and we designed a Kanban flow with a number of different stages that each application would go through. The first stage was a senior level technical lead would check out the application and do a preliminary survey of the application to identify any risks in the conversion process and flagged those items to the development team. He would also establish coordination with the owners of the application and any other related applications to begin the conversion process. Second, an offshore team was assigned to do the conversion process and to perform initial unit testing. The application was then turned over to QA for formal QA testing, and finally, the application was staged for release and released. We had about a year to do over 100 applications, and the plan was to do about 6 to 7 applications per month. We explored a number of options to try to accelerate this process, and this is a good example of how the theory of constraints can be used to accelerate a process. This slide shows their recommended steps in doing an analysis for the theory of constraints. The first step is to identify the stage or portion of the process that is the most critical constraint or bottleneck. For example, in the customer service system, it may be that there are not enough people to handle calls and to do the initial screening, and as a result, people are waiting for a long time to get through. The second step is to do whatever you can to exploit or optimize that portion of the process to make it more efficient. For example, in the customer service response system, you might add an improved interactive voice response system that would provide some level of initial screening to relieve the load on the people answering the calls. The third step is that after you've done whatever you can to optimize the performance of that constraint, you should subordinate everything else in the process to work within that limitation. For example, if the number of people available to answer the phone is limitation, there is no point in having an excessive number of people in the second stage to resolve problems if those people are idle, waiting for calls to come through. If the process flow through the overall system is still not sufficient, the next step is to do whatever is necessary to elevate that constraint. For example, in the customer service response system, you might add additional resources to answer the phone until that portion of the process is no longer the limiting constraint. Finally, once you've received a bottleneck, another part of the process, then, will typically become the bottleneck. For example, in the customer service response system, if you have relieved the constraint of the frontâ€‘end people answering the calls, the people on the back end resolving problems may then become the constraint or the bottleneck, and you need to repeat the above steps with that as the new primary constraint. Here's how the theory of constraints can be used in this situation. The first step in the process is to identify the system constraint or bottleneck that is most critical for limiting the flow. In this situation, the system constraint was the resources available to perform step three in the process, which was QA testing. There are a limited number of QA resources to do the testing that was required, and they would become quickly saturated with testing because a conversion effort wasn't that difficult for many of the applications. The next step is to exploit the constraint. Given that the QA resources were the bottleneck, what can be done to optimize the use of those resources to improve the overall flow? We were able to do several things to optimize those resources, including planning the conversion process to spread the load among the QA resources we had as evenly as possible. Once we had done everything we could to optimize the QA resources, it made no sense for the conversion process to go faster than QA could handle the applications. As a result, the application conversion effort needed to be slowed down to match the speed of the QA process, otherwise, a very large queue of applications waiting to be tested would have piled up in QA. The next step to improve the flow would be to add more QA resources to elevate the constraint and to reduce the bottleneck. In this particular situation, that was not an option. Of course, if you add enough QA resources at some point, that will no longer be the most critical constraint, and the bottleneck will move somewhere else in the process such as the number of developers to do the conversion process. We never really got to that point in this particular example.
```

## Notes
The Theory of Constraints (TOC), originally developed by Eliyahu Goldratt in his book "The Goal," offers a systematic approach to identify and optimize constraints or bottlenecks in a process flow. The goal is to improve the overall flow and efficiency of a system. In your example of upgrading over 100 legacy applications, you applied TOC principles to expedite the process. Let's summarize the steps in applying the Theory of Constraints:

1. **Identify the Constraint or Bottleneck:**
   - Determine which stage or part of the process is limiting the flow of work.
   - In your example, the bottleneck was the limited QA testing resources.

2. **Exploit the Constraint:**
   - Optimize the performance of the constraint to make it more efficient.
   - Find ways to get the most out of the bottleneck without overloading it.
   - In your case, you optimized QA testing by planning the conversion process to evenly distribute work among available resources.

3. **Subordinate Everything Else:**
   - Ensure that the rest of the process aligns with and operates within the constraints' capacity.
   - Avoid overloading non-bottleneck stages to prevent unnecessary delays.
   - For your project, it meant slowing down the application conversion process to match the speed of the QA testing.

4. **Elevate the Constraint:**
   - If the process flow remains insufficient after exploiting and subordinating, consider adding more resources or taking corrective actions to alleviate the constraint.
   - In your example, adding more QA resources to increase testing capacity could have been a solution.

5. **Repeat the Process:**
   - Once a previous constraint is no longer the bottleneck, another part of the process may become the new constraint.
   - Continue identifying and addressing constraints throughout the project.

Applying TOC principles helps ensure that the process flows smoothly, and work progresses at a consistent pace without excessive queuing or delays. By focusing on the most critical constraint, you can make targeted improvements and drive the overall efficiency of the project. In your specific case, recognizing and addressing the bottleneck in the QA testing stage allowed you to better align the application conversion process with available resources, ultimately optimizing the flow of work.